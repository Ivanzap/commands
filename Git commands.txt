  -- untracked файлы - файлы, которые созданы в репозитории, но не добавлены (без команды git add)
  -- staged файлы - файлы, которые подготовленны к коммиту (после add)
  -- unstaged файлы - файлы, которые не подготовлены к коммиту (после reset --mixed)
  -- modifield файлы - файлы, которые не untracked, но которые изменены
  
  -- git config --global user.name Имя Фамилия
  
  -- git config --global user.email название мейла
  
  -- git config --global color.ui true - выставить выделение цветом
  
  -- cd название дерриктории - выбрать деррикторию, где развернуть проект
  
  -- mkdir название_проекта - создать деррикторию с названием название_проекта
  
  -- git init - активировать текущую директорию
  
  -- git status - узнать текущий статус репозитория
  
  -- git add имя_фала - добавить статус файлу staged (подготовленный) или подготовить файл(-ы) к commit’у
    -- git add <список файлов> - git add file1 file2
    -- git add . - добавить все файлы в текущей папке
    -- git add *.java - добавить все файлы в текущей папке с расширением .java
    -- git add someDir/*.java - добавить все файлы в папке someDir с расширением .java
    -- git add someDir/ - добавить все файлы в папке someDir
    -- git add “*.java” - добавить все файлы в проекте с расширением .java
  
  -- git commit -m "сообщение" - установить статус committed (зафиксированный или сдеать снимок)
    -- git commit -a -m "сообщение" - тоже самое, что  последовательное выполнение git add . и git commit -m "сообщение". !!! при этом добавляются только modifield файлы, новые файлы не добавляются
    -- git commit --amend -m "новое сообщение коммита" - дополнение последнего коммита свежими изменениями (новый коммит не создается). И можно изменить сообщение коммита
      -- :wq - подтвердить изменение коммита
    
  -- git log - позволяет посмотреть всю историю commit'ов снизу вверх
  
  -- git diff - Показывает разницу между текущим неотслеживаемым состоянием репозитория и последним снимком репозитория
    -- git diff --staged показывает разницу между текущим отслеживаемым состоянием репозитория и последним снимком репозитория
    -- git diff COMMIT_ID показывает разницу между текущим состоянием репозитория и указанным снимком репозитория
  
  -- git reset - предназначена для отмены какиз-либо изменений в проекте, откату проекта к какому-то снимку
    -- git reset --hard HEAD^^ (или хэш_коммита) - возвращение проекта к указанному коммиту с полным удалением коммитов после указанного. (безвозвратное удаление коммитов)
    -- git reset --mixed HEAD^^ (или хэш_коммита) - возвращает проект к указанному коммиту, все коммиты после указанного переводит в неотслеживаемую зону (unstaged)
    -- git reset --soft HEAD^^ (или хэш_коммита) - возвращает проект к указанному коммиту, все коммиты после уазанного переводит в отслеживаемую зону (staged).
    -- git reset HEAD^^ = git reset --mixed HEAD^^
    -- git reset = git reset --mixed HEAD
  
  -- HEAD - указатель, обычно указывает на последний текущий коммит
    -- HEAD^ - смещение указателя на один коммит назад
    -- HEAD^^ - на два коммита назад
    -- HEAD~2 - на два коммита назад
    
  -- git checkout - команда используется для перемещения между коммитами, версиями отдельных файлов и ветками
    -- git checkout HEAD^^ - перенесет указатель HEAD на два коммита назад. Теперь указатель HEAD находится в состоянии DETACHED(отделенный). Из такого состояния нельзя сделать новые коммиты
    -- git checkout master - переход обратно к актуальному коммиту в текущей ветке
    -- git checkout master - переход на ветку master
    -- git checkout --master - возвращение файла с названием master к вресии последнего коммита
    -- git checkout указатель_коммита -- имя_файла1 имя_файла2 - возврат файлов к версии указанного коммита
    -- git checkout -- имя_файла1 имя_файла2 - возврат файлов к версии, которая была у них в последнем коммите(HEAD). РАботает только для неотслеживаемых изменений(untracked или modified) 
    -- git checkout -- . - вовзрат всех файлов в репозитории к версии, которая была у них в последнем коммите(HEAD). Работает только для неотслеживаемых изменений(untracked или modified) 
    
  -- master - Название текущей ветки
  
  -- git clean -n - выдает сообщение с файлами, которые будут удалены (untracked файлы)
  -- git clean -f - удаляет untracked файлы из репозитория
  
  -- git remote add придумать_название_репозитория адрес_репозитория - добавить новый удаленный репозиторий, который находится по указанному адресу. При этом, на нашем компьютере к удаленному репозиторию мы будем обращаться по его названию
    -- git remote add origin https://github.com/Ivanzap/firstWork.git - название origin, адрес на github
  -- git remote -v - просмотр списка существующих удаленных репозиториев
  -- git remote remove название_репозитория - удаление ссылки на удаленный репозиторий
  -- git remote origin show - команда выдает информацию о ветках проекта. (up to date) говорит, что данные с удаленного репозитория github не совпадают с данными удаленного репозитория на компьютере
  
  -- git push название_репозитория название_ветки - Отправляем на удаленный репозиторий с именем название_репозитория нашу ветку название_ветки
    -- git push origin master - Отправляем на удаленный репозиторий с именем origin нашу ветку master
  -- git push --delete origin название_ветки - эта команда удалит ветку название_ветки на удаленном репозитории github
  
  -- git pull название_репозитория название_ветки - команда для получения обновлений с удаленного репозитория 
    -- git pull origin master - получаем обновленные данные с удаленного репозитория origin из ветки master
    -- git pull название_репозитория название_ветки - скачивает удаленную ветку с удаленного репозитория (обновляет ветку origin/master)
                                                    - сливает удаленную ветку с локальной веткой (производит актуализацию локальной ветки)
    -- git pull название_репозитория название_ветки - git fetch + git merge origin/master
    -- git pull название_репозитория название_ветки - подтягивает изменения из ветки master (github) в ветку на локальном компютере origin/master
    
  -- git fetch - скачивает удаленную ветку с репозитория, без слияния удаленной ветки с локальной (обновление ветки origin/master)
  
  -- SSH - Secure SHell - "безопасная оболочка"
  -- SSH - Сетевой протокол, позволяющий производить удаленное управление операционной системой
  -- SSH - позволяет безопасно передавать данные в незащещенной среде
  -- SHH - У клиента на хосте есть публичный ключ, которые надо предоставить github, для установления связи
  
  -- git clone адрес_репозитория - клонирование репозитория в директорию. (Вместо создания директории, git init, git remote add)
  
  -- git branch название_ветки - команда для создания новой ветки с текущего коммита
  -- git branch - покажет на какой ветке сейчас находимся, а также список веток (на локальном компьютере)
  -- git branch -d название_ветки - удаление ветки
  -- git branch -D название_ветки - удаление ветки, даже если в ней есть коммиты, которые не замерджены в другую ветку
  -- git branch -r - получить список удалённых веток (с github), которые расположены на локальном компьютере
  
  -- master - локальная ветка на локальном компьютере
  -- origin/master - ветка на локальном компьютере, которая связана с удаленной веткой master на github
  
  -- git checkout название_ветки - переключение на ветку название_ветки
  -- git checkout название_ветки - создает локальную ветку на основании существующей удаленной ветки
  
  -- git merge название_ветки - добавление в текущую ветку изменения из ветки название_ветки
      - Fast-Forward merge - случай, когда в ветке master не было больше коммитов, и слияние с параллельной веткой происходит быстро (не создается отдельный коммит для слияния)
      - recursive merge (NON Fast-Forward merge) - случай, когда в ветке master появились коммиты и при слиянии с параллельной веткой может возникнуть конфликт. В безконфликтном случае создастся дополнительный коммит, перед ним появится коммит из параллельной ветки 
        -- :wq - подтвердить merge
      - если происходит конфликт у одного пользователя в двух разных ветках (изменен по своему один и тот же файл, в разных ветках), то после merge появится сообщение что надо зафиксировать конфликт и сделать коммит. После чего открываем конфликтный файл и оставляем необходимое изменение, затем делаем add и commit. Т.Е. В новой ветке изменил file1 -> add . -> commit, а затем переключился на ветку master. Изменил file1 -> add . -> commit -> merge (из новой ветки) (fix conflict, open file1 and need to change variant) -> add . -> commit. 
      - если происходит конфликт у нескольких пользователей. push (failed) -> pull (fix conflict, open file and need to change variant) -> add . -> commit -> push 
 
  -- git rebase - альтернатива merge, выполняет слияние и не создает коммитов слияния (которые могут засорять историю коммитов) 
                - комманда merge безопасней, т.к. создает отдельный коммит, отображающий слияние
                - команда Merge пердоставляет полную история коммитов
                - команда rebase предоставляет локаничную линейную историю без лишних коммитов
                - если в ветке долго велась работа и произошло много изменений, то лучше использовать merge
                - если ветка была недолгая и произошло мало изменений - можно использовать rebase
                - если не просят делать rebase, То лучше делать merge
  -- git rebase master - команда выполняется в той ветке, которую надо перебазировать. При выполнении команды точка ответвления текущей ветки перебазируется в точку полседнего коммита ветки master (без создания коммита слияния)
  -- git rebase add-feature1 - вставляет в ветку master все коммиты из ветки add-feature1 сразу после того коммита, от которого ответвилась ветка add-feature1
    - могут быть конфликты слияния (аналогично конфликтам merge)
  -- git rebase --continue - продожить слияние веток
  -- git rabase --abort - отменить слияние веток
  -- git rebase --skip - пропустить коммит, который выполняет слияние
  -- git rabase - бывает обычный и интерактивный
                - обычный нужен для манипуляции с ветками
                - интерактивный работает на одной ветке
                - обычный берет коммиты из другой ветки, перемещает их в нашу ветку и поверх этих коммитов по одному применят коммиты из временоой зоны
                - интерактивный не берет коммиты из другой ветки, он помещает некоторые коммиты из текущей ветки во временную зону и потом применяет эти коммиты опять к текущей ветке (в момент применения мы можем изменить коммиты)
                - интерактивный rebase может:
                  - поменять коммиты местами
                  - поменять название коммитов
                  - объеденить два коммита в один
                  - добавить изменения в существующий коммит
                  - разделить коммит на несколько коммитов
  -- git rebase -i HEAD~3 - вызываем интерактиный rebase для изменения трех последних коммитов
    - для внесения изменений надо нажать i
      - pick - использовать коммиты в нужном порядке
      - reword - переименновать нужный коммит
      - squash - слияние коммита с предыдущим коммитом
      - edit - добавить изменение в нужный коммит
    - после изменений надо нажать ESC, :wq
  
  -- git cheryy-pick - команда для отбора хорошего/хороших коммита из другой ветки
  -- git cherry-pick hash-commit'а - команда для добавления коммита в текующую ветку по hash номеру коммита
  -- git cherry-pick --edit - перенос коммита из другой ветки с изменением сообщения коммита
  -- git cherry-pick --no-commit hash_commit1 hash_commit2 - команда для внесения небольших правок в переносимый коммит
                                                           - слияние двух коммитов из другой ветки в один коммит
  -- git cherry-pick -x hash_commit - указывает в сообщении коммита хэш того коммита, из которого мы сделали cherry-pick
  -- git cherry-pick --signoff hash_commit - указывает в сообщении коммита имя того пользователя, кто совершил cherry-pick
  